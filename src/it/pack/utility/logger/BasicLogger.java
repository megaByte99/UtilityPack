package it.pack.utility.logger;

import java.lang.System.Logger.Level;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class BasicLogger {

    /**
     * Parameters to use in log write method.
     */
    private enum Params { START, ERROR, NONE};

    /**
     * <p style="line-height: 1.4">
     * The default path for {@code /log} folder.<br>
     * By default, if is not passed in parameter, the location will be {@code <project path>/log}.
     * </p>
     */
    public static final  Path       DEFAULT_LOG_FOLDER      = Paths.get(System.getProperty("user.dir")).resolve("log");

    private static final String     LOG_FILE_NAME           = "run_%s.log";
    private static final String     MESSAGE_FORMATTER       = "[%s][%s - %s:%d] %s\n";
    private static final String     LOG_START_HEADER        = "------------------------ Start Log %s ------------------------\n";

    private static final DateTimeFormatter FORMAT_DAYTIME   = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss");

    // Flags indicates if file logging is enabled
    private boolean writeToFile;

    // The path of log file
    private Path logPath;

    // The logger name (most of the time it corresponds to the name of the class that is using it).
    private String loggerName;

    // Private constructor
    private BasicLogger() { /* ... */ }

    public static BasicLogger getLogger(Class<?> _class) {
        return getLogger(_class, null);
    }

    public static BasicLogger getLogger(Class<?> _class, Path logDir) {
        // Create a new instance
        BasicLogger instance = new BasicLogger();
        // Prepare the logger
        instance.prepareLogger(_class.getSimpleName(), logDir);
        // Return it
        return instance;
    }

    private void prepareLogger(String loggerName, Path logDir) {
        this.loggerName = loggerName;
        if (logDir != null) {
            try {
                // Create the folder
                Files.createDirectories(logDir);
                // Create the file
                logPath = logDir.resolve(String.format(
                        LOG_FILE_NAME,
                        LocalDate.now().format(DateTimeFormatter.ofPattern("ddMMyyyy"))
                ));

                if (Files.notExists(logPath))
                    Files.createFile(logPath);

                writeToFile = true;
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        } else
            writeToFile = false;

        log(Level.INFO, "", Params.START);
    }

    private void log(Level level, String message, Params param) {
        // Get current time
        String now = LocalDateTime.now().format(FORMAT_DAYTIME);

        // Create the message to display
        String formattedMsg = (param.equals(Params.START))
                ? LOG_START_HEADER .formatted(now)
                : MESSAGE_FORMATTER.formatted(now, level.getName(), loggerName, getLineNumber(), message);

        // Print the message on console
        System.out.print(formattedMsg);

        // Write the message in the file
        if (writeToFile && !param.equals(Params.ERROR)) {
            try {
                Files.writeString(logPath, formattedMsg, StandardOpenOption.APPEND);
            } catch (Exception e) {
                this.log(System.Logger.Level.ERROR, printException(e), Params.ERROR);
            }
        }
    }

    /**
     * <p style="text-align:justify; line-height: 1.3">
     * Format the message generated by {@link Exception} by creating a sort of tree view using the {@code '\t' char}
     * with the main message at the beginning and below all the {@link StackTraceElement}
     * </p>
     * @param ex the {@link Exception} that was thrown
     * @return the formatted {@link Exception} message
     */
    private String printException(Exception ex) {
        StringBuilder exceptionMessage = new StringBuilder("Exception " + ex.toString() + " at:\n");

        for (StackTraceElement e : ex.getStackTrace())
            exceptionMessage.append("\t\t").append(e.toString()).append("\n");

        return exceptionMessage.toString();
    }

    /**
     * Returns the line number of the source line containing the execution point represented by this stack trace element.
     * @see StackTraceElement#getLineNumber()
     *
     * @return the line number of the source line
     */
    private int getLineNumber() {
        return Thread.currentThread().getStackTrace()[4].getLineNumber();
    }

    /* ---------------------------------------- Message Printer ---------------------------------------- */

    public void info(String message) {
        log(Level.INFO, message, Params.NONE);
    }

    public void warning(String message) {
        log(Level.WARNING, message, Params.NONE);
    }

    public void trace(String message) {
        log(Level.TRACE, message, Params.NONE);
    }

    public void debug(String message) {
        log(Level.DEBUG, message, Params.NONE);
    }

    public void error(String message) {
        log(Level.ERROR, message, Params.NONE);
    }

    public void error(String message, Exception e) {
        log(Level.ERROR, message + "\n\t" + printException(e), Params.NONE);
    }
}
